/****************************************************
 *                vector_calculus.bc                *
 ****************************************************

  Author: Marc Mel√©ndez Schofield

  Simple numerical derivatives and integrals. Set
  generic_f equal to the function of interest before
  calculating derivatives or integrals. */

/* Default generic function f(x) = x */
define generic_f(x) { return x; }

/* Numerical derivative of generic_f at point x with
   step size dx */
define diff(x, dx) {
  return (generic_f(x + dx) - generic_f(x))/dx;
}

/* Numerical nth derivative of generic_f at point x
   with step size dx */
define diffn(n, x, dx) {
  if (n == 0) return generic_f(x);
  if (n == 1) return diff(x, dx);
  if (n < 0)
  {
    print "Error: n must be a positive integer.\n";
    return 1/0;
   }
   return (diffn(n - 1, x + dx, dx) - diffn(n - 1, x, dx))/dx;
}

/* Numerical integral of generic_f from a to b with
   step size dx, using Euler's algorithm */
define integral(a, b, dx) {
  auto x, integ;
  for(x = a; x < b; x += dx)
    integ += generic_f(x)*dx;
  return integ;
}

/* Numerical integral of generic_f from a to b with
   step size dx, using Simpson's algorithm */
define simpson(a, b, dx) {
  auto x, integ;
  for(x = a; x < b; x += dx)
    integ += (dx/6.0)*(generic_f(x) + generic_f(x + dx) + 4*generic_f(x + 0.5*dx));
  return integ;
}

/* Default generic dimensionality */
generic_dim = 3;

/* Partial derivatives */
define partial_diff(idx[], x[], dx) {
  auto n, m, newx[], newidx[];
  for(n = 0; n < generic_dim; n++) {
    if(idx[n] > 0) {
      for(m = 0; m < generic_dim; m++) {
          newidx[m] = idx[m];
      }
      . = newidx[n]--;
      newx[n] = x[n] + dx;
      return (partial_diff(newidx[], newx[], dx) - partial_diff(newidx[], x[], dx))/dx;
    }
  }
  return generic_f(x[]);
}

/* Gradient */
define grad(x[], *gradf[], dx) {
  auto n;
  for(n = 0; n < generic_dim; n++) {
    x[n] += dx;
    gradv[n] = generic_f(x[]);
    x[n] -= dx;
    gradv[n] = generic_f(x[]));
    gradv[n] /= dx;
  }
}

/* Divergence */
define div(x[], dx) {
  auto n, divf;
  divf = 0;
  for(n = 0; n < generic_dim; n++) {
    x[n] += 0.5*dx;
    divf += generic_f(x[])/dx;
    x[n] -= dx;
    divf -= generic_f(x[])/dx;
  }
  return divf;
}

/* Rotational */

/* Laplacian */
define laplacian(x[], dx) {
  auto n, delf;
  delf = 0;
  for(n = 0; n < generic_dim; n++) {
    x[n] -= dx;
    delf -= generic_f(x[])/dx^2;
    x[n] += 2*dx;
    delf -= generic_f(x[])/dx^2;
    x[n] -= dx;
    delf += 2*generic_f(x[])/dx^2;
  }
  return delf;
}
